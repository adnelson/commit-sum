import fs from "fs";

import { Command } from "commander";
import OpenAI from "openai";
import simpleGit from "simple-git";
import { z } from "zod";

if (!process.env.OPENAI_API_KEY) {
  console.error("Error: OPENAI_API_KEY is not set in the environment.");
  process.exit(1);
}

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Use this variable as a flag to detect if we're running inside of an invocation of git commit.
const isGitCommit = !!process.env.GIT_EXEC_PATH;

const dotfileSchema = z.object({
  minWords: z.number().optional(),
  maxWords: z.number().optional(),
  guidance: z.string().optional(),
});

type Options = z.infer<typeof dotfileSchema>;

const LOCK_FILES = [
  "yarn.lock",
  "package-lock.json",
  "pnpm-lock.yaml",
  "Gemfile.lock",
  "poetry.lock",
  "Cargo.lock",
  "uv.lock",
];

async function main(
  from: "modified" | "staged" | "all",
  { guidance, minWords, maxWords }: Options,
) {
  const git = simpleGit();

  const diffOpts = [];
  for (const f of LOCK_FILES) {
    if (fs.existsSync(f)) diffOpts.push(`:!${f}`);
  }
  if (from === "staged") {
    diffOpts.unshift("--staged");
  } else if (from === "all") {
    diffOpts.unshift("HEAD");
  }
  const diff = await git.diff(diffOpts);

  if (!diff.trim()) {
    console.error(`No changes found (mode=${from})`);
    process.exit(1);
  }

  const prompt = [
    "Based on the following diff, generate a git commit message. Your answer should be in the form of a JSON object with a single key, `message`",
  ];
  if (guidance) prompt.push(guidance);
  if (minWords && maxWords) {
    prompt.push(`The message should be between ${minWords} and ${maxWords} words`);
  } else if (minWords) {
    prompt.push(`The message should be at least ${minWords} words`);
  } else if (maxWords) {
    prompt.push(`The message should be no more than ${maxWords} words`);
  }

  const response = await client.chat.completions.create({
    model: "gpt-4o-mini", // You can change to another model like "gpt-4.1"
    messages: [
      {
        role: "user",
        content: prompt.join(". ") + "\n\n```\n" + diff + "\n```\n",
      },
    ],
    response_format: { type: "json_object" },
  });

  let message: string | undefined;
  try {
    const contentJson = response.choices[0]?.message.content;
    if (!contentJson) throw new Error("No content returned in message");
    message = z.object({ message: z.string() }).parse(JSON.parse(contentJson)).message;
  } catch (e) {
    console.error("OpenAI response:", response);
    throw e;
  }

  const suffix = isGitCommit ? `\n\n#### This message was autogenerated by commit-sum` : "";
  console.log(message + suffix);
}

const program = new Command();

const OPTIONS_FILE = ".commit-sum.json";

program
  .name("commit-sum")
  .description("Generate a commit message with OpenAI")
  .argument("[directory]", "Directory to analyze (defaults to current working directory)")
  .option("--modified", "Summarize modified files (i.e. unstaged)")
  .option("--all", "Summarize all changes, both staged and unstaged")
  .option("--staged", "Summarize staged files (default)")
  .option("--guidance <string>", "Give extra guidance to the AI to customize the message")
  .option("--min-words <number>", "Minimum number of words in the message")
  .option("--max-words <number>", "Maximum number of words in the message")
  .action(async (directory, cliOptions) => {
    if (directory) process.chdir(directory);

    const from = cliOptions.modified ? "modified" : cliOptions.all ? "all" : "staged";
    const guidance = cliOptions.guidance ?? process.env.GUIDANCE;
    const minWords = cliOptions.minWords ? parseInt(cliOptions.minWords) : undefined;
    const maxWords = cliOptions.maxWords ? parseInt(cliOptions.maxWords) : undefined;

    const options: Options = { guidance, minWords, maxWords };
    if (fs.existsSync(OPTIONS_FILE)) {
      const optionsStr = fs.readFileSync(OPTIONS_FILE, "utf-8");
      try {
        const parsed = dotfileSchema.parse(JSON.parse(optionsStr));
        options.guidance ??= parsed.guidance;
        options.minWords ??= parsed.minWords;
        options.maxWords ??= parsed.maxWords;
      } catch (e) {
        console.warn(`Error parsing ${OPTIONS_FILE}:`, e);
      }
    }

    await main(from, options);
  });

program.parse();
